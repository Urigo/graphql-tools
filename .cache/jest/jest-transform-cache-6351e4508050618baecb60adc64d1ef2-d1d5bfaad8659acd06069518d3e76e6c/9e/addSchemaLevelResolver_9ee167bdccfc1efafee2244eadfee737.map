{"file":"/home/ardat_000/Guild/graphql-tools/packages/schema/src/addSchemaLevelResolver.ts","mappings":"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","names":[],"sources":["/home/ardat_000/Guild/graphql-tools/packages/schema/src/addSchemaLevelResolver.ts"],"sourcesContent":["import { defaultFieldResolver, GraphQLSchema, GraphQLFieldResolver } from 'graphql';\nimport { mapSchema, MapperKind } from '@graphql-tools/utils';\n\n// wraps all resolvers of query, mutation or subscription fields\n// with the provided function to simulate a root schema level resolver\nexport function addSchemaLevelResolver(schema: GraphQLSchema, fn: GraphQLFieldResolver<any, any>): GraphQLSchema {\n  // TODO test that schema is a schema, fn is a function\n  const fnToRunOnlyOnce = runAtMostOncePerRequest(fn);\n  return mapSchema(schema, {\n    [MapperKind.ROOT_FIELD]: (fieldConfig, _fieldName, typeName, schema) => {\n      // XXX this should run at most once per request to simulate a true root resolver\n      // for graphql-js this is an approximation that works with queries but not mutations\n      // XXX if the type is a subscription, a same query AST will be ran multiple times so we\n      // deactivate here the runOnce if it's a subscription. This may not be optimal though...\n      const subscription = schema.getSubscriptionType();\n      if (subscription != null && subscription.name === typeName) {\n        return {\n          ...fieldConfig,\n          resolve: wrapResolver(fieldConfig.resolve, fn),\n        };\n      }\n\n      return {\n        ...fieldConfig,\n        resolve: wrapResolver(fieldConfig.resolve, fnToRunOnlyOnce),\n      };\n    },\n  });\n}\n\n// XXX badly named function. this doesn't really wrap, it just chains resolvers...\nfunction wrapResolver(\n  innerResolver: GraphQLFieldResolver<any, any> | undefined,\n  outerResolver: GraphQLFieldResolver<any, any>\n): GraphQLFieldResolver<any, any> {\n  return (obj, args, ctx, info) =>\n    resolveMaybePromise(outerResolver(obj, args, ctx, info), root => {\n      if (innerResolver != null) {\n        return innerResolver(root, args, ctx, info);\n      }\n      return defaultFieldResolver(root, args, ctx, info);\n    });\n}\n\nfunction isPromise<T>(maybePromise: Promise<T> | T): maybePromise is Promise<T> {\n  return maybePromise && typeof (maybePromise as Promise<T>).then === 'function';\n}\n\n// resolvers can be synchronous or asynchronous. if all resolvers\n// in an operation return synchronously, the execution should return\n// synchronously. the maybe-sync/maybe-async nature of resolvers should be\n// preserved\nfunction resolveMaybePromise<T, U>(maybePromise: Promise<T> | T, fulfillmentCallback: (value: T) => U): Promise<U> | U {\n  if (isPromise(maybePromise)) {\n    return maybePromise.then(fulfillmentCallback);\n  }\n  return fulfillmentCallback(maybePromise);\n}\n\n// XXX this function only works for resolvers\n// XXX very hacky way to remember if the function\n// already ran for this request. This will only work\n// if people don't actually cache the operation.\n// if they do cache the operation, they will have to\n// manually remove the __runAtMostOnce before every request.\nfunction runAtMostOncePerRequest(fn: GraphQLFieldResolver<any, any>): GraphQLFieldResolver<any, any> {\n  let value: any;\n  const randomNumber = Math.random();\n  return (root, args, ctx, info) => {\n    if (!info.operation['__runAtMostOnce']) {\n      info.operation['__runAtMostOnce'] = {};\n    }\n    if (!info.operation['__runAtMostOnce'][randomNumber]) {\n      info.operation['__runAtMostOnce'][randomNumber] = true;\n      value = fn(root, args, ctx, info);\n    }\n    return value;\n  };\n}\n"],"version":3}