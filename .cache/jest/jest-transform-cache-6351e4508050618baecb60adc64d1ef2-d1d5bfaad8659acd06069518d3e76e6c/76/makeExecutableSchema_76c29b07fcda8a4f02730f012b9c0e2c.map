{"file":"/home/ardat_000/Guild/graphql-tools/packages/schema/src/makeExecutableSchema.ts","mappings":"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","names":[],"sources":["/home/ardat_000/Guild/graphql-tools/packages/schema/src/makeExecutableSchema.ts"],"sourcesContent":["import { GraphQLFieldResolver } from 'graphql';\n\nimport { mergeDeep, SchemaDirectiveVisitor, pruneSchema } from '@graphql-tools/utils';\nimport { addResolversToSchema } from './addResolversToSchema';\n\nimport { attachDirectiveResolvers } from './attachDirectiveResolvers';\nimport { assertResolversPresent } from './assertResolversPresent';\nimport { addSchemaLevelResolver } from './addSchemaLevelResolver';\nimport { buildSchemaFromTypeDefinitions } from './buildSchemaFromTypeDefinitions';\nimport { addErrorLoggingToSchema } from './addErrorLoggingToSchema';\nimport { addCatchUndefinedToSchema } from './addCatchUndefinedToSchema';\nimport { ExecutableSchemaTransformation, IExecutableSchemaDefinition } from './types';\n\n/**\n * Builds a schema from the provided type definitions and resolvers.\n *\n * The type definitions are written using Schema Definition Language (SDL). They\n * can be provided as a string, a `DocumentNode`, a function, or an array of any\n * of these. If a function is provided, it will be passed no arguments and\n * should return an array of strings or `DocumentNode`s.\n *\n * Note: You can use `graphql-tag` to not only parse a string into a\n * `DocumentNode` but also to provide additional syntax highlighting in your\n * editor (with the appropriate editor plugin).\n *\n * ```js\n * const typeDefs = gql`\n *   type Query {\n *     posts: [Post]\n *     author(id: Int!): Author\n *   }\n * `;\n * ```\n *\n * The `resolvers` object should be a map of type names to nested object, which\n * themselves map the type's fields to their appropriate resolvers.\n * See the [Resolvers](/docs/resolvers) section of the documentation for more details.\n *\n * ```js\n * const resolvers = {\n *   Query: {\n *     posts: (obj, args, ctx, info) => getAllPosts(),\n *     author: (obj, args, ctx, info) => getAuthorById(args.id)\n *   }\n * };\n * ```\n *\n * Once you've defined both the `typeDefs` and `resolvers`, you can create your\n * schema:\n *\n * ```js\n * const schema = makeExecutableSchema({\n *   typeDefs,\n *   resolvers,\n * })\n * ```\n */\nexport function makeExecutableSchema<TContext = any>({\n  typeDefs,\n  resolvers = {},\n  logger,\n  allowUndefinedInResolve = true,\n  resolverValidationOptions = {},\n  directiveResolvers,\n  schemaDirectives,\n  schemaTransforms: userProvidedSchemaTransforms,\n  parseOptions = {},\n  inheritResolversFromInterfaces = false,\n  pruningOptions,\n  updateResolversInPlace = false,\n  noExtensionExtraction = false,\n}: IExecutableSchemaDefinition<TContext>) {\n  // Validate and clean up arguments\n  if (typeof resolverValidationOptions !== 'object') {\n    throw new Error('Expected `resolverValidationOptions` to be an object');\n  }\n\n  if (!typeDefs) {\n    throw new Error('Must provide typeDefs');\n  }\n\n  // Arguments are now validated and cleaned up\n  const schemaTransforms: ExecutableSchemaTransformation[] = [\n    schema => {\n      // We allow passing in an array of resolver maps, in which case we merge them\n      const resolverMap: any = Array.isArray(resolvers) ? resolvers.reduce(mergeDeep, {}) : resolvers;\n\n      const schemaWithResolvers = addResolversToSchema({\n        schema,\n        resolvers: resolverMap,\n        resolverValidationOptions,\n        inheritResolversFromInterfaces,\n        updateResolversInPlace,\n      });\n\n      if (Object.keys(resolverValidationOptions).length > 0) {\n        assertResolversPresent(schemaWithResolvers, resolverValidationOptions);\n      }\n\n      return schemaWithResolvers;\n    },\n  ];\n\n  if (!allowUndefinedInResolve) {\n    schemaTransforms.push(addCatchUndefinedToSchema);\n  }\n\n  if (logger != null) {\n    schemaTransforms.push(schema => addErrorLoggingToSchema(schema, logger));\n  }\n\n  if (typeof resolvers['__schema'] === 'function') {\n    // TODO a bit of a hack now, better rewrite generateSchema to attach it there.\n    // not doing that now, because I'd have to rewrite a lot of tests.\n    schemaTransforms.push(schema =>\n      addSchemaLevelResolver(schema, resolvers['__schema'] as GraphQLFieldResolver<any, any>)\n    );\n  }\n\n  if (userProvidedSchemaTransforms) {\n    schemaTransforms.push(schema =>\n      userProvidedSchemaTransforms.reduce((s, schemaTransform) => schemaTransform(s), schema)\n    );\n  }\n\n  // directive resolvers are implemented using SchemaDirectiveVisitor.visitSchemaDirectives\n  // schema visiting modifies the schema in place\n  if (directiveResolvers != null) {\n    schemaTransforms.push(schema => attachDirectiveResolvers(schema, directiveResolvers));\n  }\n\n  if (schemaDirectives != null) {\n    schemaTransforms.push(schema => {\n      SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);\n      return schema;\n    });\n  }\n\n  if (pruningOptions) {\n    schemaTransforms.push(pruneSchema);\n  }\n\n  const schemaFromTypeDefs = buildSchemaFromTypeDefinitions(typeDefs, parseOptions, noExtensionExtraction);\n\n  return schemaTransforms.reduce((schema, schemaTransform) => schemaTransform(schema), schemaFromTypeDefs);\n}\n"],"version":3}