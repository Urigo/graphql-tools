{"file":"/home/ardat_000/Guild/graphql-tools/packages/mock/src/types.ts","mappings":";;;AA0LA,SAAgB,KAAK,CAA2C,QAAiB;IAC/E,OAAO,QAAQ,IAAI,OAAO,QAAQ,KAAK,QAAQ,IAAI,QAAQ,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;AACrF,CAAC;AAFD,sBAEC;AAED,SAAgB,WAAW,CACzB,QAAiB,EACjB,OAAgB;IAEhB,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE;QACpB,MAAM,IAAI,KAAK,CAAC,OAAO,IAAI,YAAY,QAAQ,qBAAqB,CAAC,CAAC;KACvE;AACH,CAAC;AAPD,kCAOC;AAED,SAAgB,QAAQ,CAAC,GAAY;IACnC,OAAO,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,KAAK,IAAI,CAAC;AACjD,CAAC;AAFD,4BAEC","names":[],"sources":["/home/ardat_000/Guild/graphql-tools/packages/mock/src/types.ts"],"sourcesContent":["import { ExecutionResult, GraphQLSchema } from 'graphql';\n\nexport type IMockFn = () => unknown;\nexport type IScalarMock = unknown | IMockFn;\nexport type ITypeMock = () => { [fieldName: string]: unknown | IMockFn } | { [fieldName: string]: IMockFn };\n\nexport type IMocks = {\n  [typeOrScalarName: string]: IScalarMock | ITypeMock;\n};\n\nexport type KeyTypeConstraints = string | number;\n\nexport type TypePolicy = {\n  /**\n   * The name of the field that should be used as store `key`.\n   *\n   * If `false`, no field will be used and we'll generate a random string\n   * as key.\n   */\n  keyFieldName?: string | false;\n};\n\nexport type GetArgs<KeyT extends KeyTypeConstraints = string> = {\n  typeName: string;\n  key?: KeyT;\n  fieldName?: string;\n  /**\n   * Optional arguments when querying the field.\n   *\n   * Querying the field with the same arguments will return\n   * the same value. Deep equality is checked.\n   *\n   * ```ts\n   * store.get('User', 1, 'friend', { id: 2 }) === store.get('User', 1, 'friend', { id: 2 })\n   * store.get('User', 1, 'friend', { id: 2 }) !== store.get('User', 1, 'friend')\n   * ```\n   *\n   * Args can be a record, just like `args` argument of field resolver or an\n   * arbitrary string.\n   */\n  fieldArgs?: string | { [argName: string]: any };\n  /**\n   * If no value found, insert the `defaultValue`.\n   */\n  defaultValue?: unknown | { [fieldName: string]: any };\n};\n\nexport type SetArgs<KeyT extends KeyTypeConstraints = string> = {\n  typeName: string;\n  key: KeyT;\n  fieldName?: string;\n  /**\n   * Optional arguments when querying the field.\n   *\n   * @see GetArgs#fieldArgs\n   */\n  fieldArgs?: string | { [argName: string]: any };\n  value?: unknown | { [fieldName: string]: any };\n  /**\n   * If the value for this field is already set, it won't\n   * be overridden.\n   *\n   * Propagates down do nested `set`.\n   */\n  noOverride?: boolean;\n};\n\nexport interface IMockStore {\n  schema: GraphQLSchema;\n  /**\n   * Get a field value from the store for the given type, key and field\n   * name — and optionally field arguments. If the field name is not given,\n   * a reference to the type will be returned.\n   *\n   * If the the value for this field is not set, a value will be\n   * generated according to field return type and mock functions.\n   *\n   * If the field's output type is a `ObjectType` (or list of `ObjectType`),\n   * it will return a `Ref` (or array of `Ref`), ie a reference to an entity\n   * in the store.\n   *\n   * Example:\n   * ```ts\n   * store.get('Query', 'ROOT', 'viewer');\n   * > { $ref: { key: 'abc-737dh-djdjd', typeName: 'User' } }\n   * store.get('User', 'abc-737dh-djdjd', 'name')\n   * > \"Hello World\"\n   * ```\n   */\n  get<KeyT extends KeyTypeConstraints = string, ReturnKeyT extends KeyTypeConstraints = string>(\n    args: GetArgs<KeyT>\n  ): unknown | Ref<ReturnKeyT>;\n  /**\n   * Shorthand for `get({typeName, key, fieldName, fieldArgs})`.\n   */\n  get<KeyT extends KeyTypeConstraints = string, ReturnKeyT extends KeyTypeConstraints = string>(\n    typeName: string,\n    key: KeyT,\n    fieldNameOrFieldNames: string | string[],\n    fieldArgs?: string | { [argName: string]: any }\n  ): unknown | Ref<ReturnKeyT>;\n  /**\n   * Get a reference to the type.\n   */\n  get<KeyT extends KeyTypeConstraints = string>(\n    typeName: string,\n    keyOrDefaultValue?: KeyT | { [fieldName: string]: any },\n    defaultValue?: { [fieldName: string]: any }\n  ): unknown | Ref<KeyT>;\n\n  /**\n   * Shorthand for `get({typeName: ref.$ref.typeName, key: ref.$ref.key, fieldName, fieldArgs})`\n   * @param ref\n   * @param fieldNameOrFieldNames\n   * @param fieldArgs\n   */\n  get<KeyT extends KeyTypeConstraints = string, ReturnKeyT extends KeyTypeConstraints = string>(\n    ref: Ref<KeyT>,\n    fieldNameOrFieldNames: string | string[],\n    fieldArgs?: string | { [argName: string]: any }\n  ): unknown | Ref<ReturnKeyT>;\n\n  /**\n   * Set a field value in the store for the given type, key and field\n   * name — and optionally field arguments.\n   *\n   * If the the field return type is an `ObjectType` or a list of\n   * `ObjectType`, you can set references to other entity as value:\n   *\n   * ```ts\n   * // set the viewer name\n   * store.set('User', 1, 'name', 'Alexandre);\n   * store.set('Query', 'ROOT', 'viewer', store.get('User', 1));\n   *\n   * // set the friends of viewer\n   * store.set('User', 2, 'name', 'Emily');\n   * store.set('User', 3, 'name', 'Caroline');\n   * store.set('User', 1, 'friends', [store.get('User', 2), store.get('User', 3)]);\n   * ```\n   *\n   * But it also supports nested set:\n   *\n   * ```ts\n   * store.set('Query', 'ROOT', 'viewer', {\n   *  name: 'Alexandre',\n   *  friends: [\n   *    { name: 'Emily' }\n   *    { name: 'Caroline }\n   *  ]\n   * });\n   * ```\n   */\n  set<KeyT extends KeyTypeConstraints = string>(args: SetArgs<KeyT>): void;\n\n  /**\n   * Shorthand for `set({typeName, key, fieldName, value})`.\n   */\n  set<KeyT extends KeyTypeConstraints = string>(typeName: string, key: KeyT, fieldName: string, value?: unknown): void;\n\n  /**\n   * Set the given field values to the type with key.\n   */\n  set<KeyT extends KeyTypeConstraints = string>(\n    typeName: string,\n    key: KeyT,\n    values: { [fieldName: string]: any }\n  ): void;\n\n  /**\n   * Shorthand for `set({ref.$ref.typeName, ref.$ref.key, fieldName, value})`.\n   */\n  set<KeyT extends KeyTypeConstraints = string>(ref: Ref<KeyT>, fieldName: string, value?: unknown): void;\n\n  /**\n   * Set the given field values to the type with ref.\n   */\n  set<KeyT extends KeyTypeConstraints = string>(ref: Ref<KeyT>, values: { [fieldName: string]: any }): void;\n}\n\nexport type Ref<KeyT extends KeyTypeConstraints = string> = {\n  $ref: {\n    key: KeyT;\n    typeName: string;\n  };\n};\n\nexport function isRef<KeyT extends KeyTypeConstraints = string>(maybeRef: unknown): maybeRef is Ref<KeyT> {\n  return maybeRef && typeof maybeRef === 'object' && maybeRef.hasOwnProperty('$ref');\n}\n\nexport function assertIsRef<KeyT extends KeyTypeConstraints = string>(\n  maybeRef: unknown,\n  message?: string\n): asserts maybeRef is Ref<KeyT> {\n  if (!isRef(maybeRef)) {\n    throw new Error(message || `Expected ${maybeRef} to be a valid Ref.`);\n  }\n}\n\nexport function isRecord(obj: unknown): obj is { [key: string]: unknown } {\n  return typeof obj === 'object' && obj !== null;\n}\n\nexport interface IMockServer {\n  /**\n   * Executes the provided query against the mocked schema.\n   * @param query GraphQL query to execute\n   * @param vars Variables\n   */\n  query: (query: string, vars?: Record<string, any>) => Promise<ExecutionResult>;\n}\n"],"version":3}