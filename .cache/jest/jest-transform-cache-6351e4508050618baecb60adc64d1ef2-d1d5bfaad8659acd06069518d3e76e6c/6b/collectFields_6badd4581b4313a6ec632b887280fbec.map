{"file":"/home/ardat_000/Guild/graphql-tools/packages/utils/src/collectFields.ts","mappings":"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","names":[],"sources":["/home/ardat_000/Guild/graphql-tools/packages/utils/src/collectFields.ts"],"sourcesContent":["import {\n  GraphQLObjectType,\n  SelectionSetNode,\n  FieldNode,\n  Kind,\n  FragmentSpreadNode,\n  InlineFragmentNode,\n  getDirectiveValues,\n  GraphQLSkipDirective,\n  GraphQLIncludeDirective,\n  FragmentDefinitionNode,\n  typeFromAST,\n  isAbstractType,\n} from 'graphql';\n\nimport { GraphQLExecutionContext } from './Interfaces';\n\n/**\n * Given a selectionSet, adds all of the fields in that selection to\n * the passed in map of fields, and returns it at the end.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field which\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * Object type returned by that field.\n *\n * @internal\n */\nexport function collectFields(\n  exeContext: GraphQLExecutionContext,\n  runtimeType: GraphQLObjectType,\n  selectionSet: SelectionSetNode,\n  fields: Record<string, Array<FieldNode>>,\n  visitedFragmentNames: Record<string, boolean>\n): Record<string, Array<FieldNode>> {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        if (!shouldIncludeNode(exeContext, selection)) {\n          continue;\n        }\n        const name = getFieldEntryKey(selection);\n        if (!(name in fields)) {\n          fields[name] = [];\n        }\n        fields[name].push(selection);\n        break;\n      }\n      case Kind.INLINE_FRAGMENT: {\n        if (\n          !shouldIncludeNode(exeContext, selection) ||\n          !doesFragmentConditionMatch(exeContext, selection, runtimeType)\n        ) {\n          continue;\n        }\n        collectFields(exeContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n        break;\n      }\n      case Kind.FRAGMENT_SPREAD: {\n        const fragName = selection.name.value;\n        if (visitedFragmentNames[fragName] || !shouldIncludeNode(exeContext, selection)) {\n          continue;\n        }\n        visitedFragmentNames[fragName] = true;\n        const fragment = exeContext.fragments[fragName];\n        if (!fragment || !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {\n          continue;\n        }\n        collectFields(exeContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n        break;\n      }\n    }\n  }\n  return fields;\n}\n\n/**\n * Determines if a field should be included based on the @include and @skip\n * directives, where @skip has higher precedence than @include.\n */\nfunction shouldIncludeNode(\n  exeContext: GraphQLExecutionContext,\n  node: FragmentSpreadNode | FieldNode | InlineFragmentNode\n): boolean {\n  const skip = getDirectiveValues(GraphQLSkipDirective, node, exeContext.variableValues);\n\n  if (skip?.if === true) {\n    return false;\n  }\n\n  const include = getDirectiveValues(GraphQLIncludeDirective, node, exeContext.variableValues);\n\n  if (include?.if === false) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Determines if a fragment is applicable to the given type.\n */\nfunction doesFragmentConditionMatch(\n  exeContext: GraphQLExecutionContext,\n  fragment: FragmentDefinitionNode | InlineFragmentNode,\n  type: GraphQLObjectType\n): boolean {\n  const typeConditionNode = fragment.typeCondition;\n  if (!typeConditionNode) {\n    return true;\n  }\n  const conditionalType = typeFromAST(exeContext.schema, typeConditionNode);\n  if (conditionalType === type) {\n    return true;\n  }\n  if (isAbstractType(conditionalType)) {\n    return exeContext.schema.isPossibleType(conditionalType, type);\n  }\n  return false;\n}\n\n/**\n * Implements the logic to compute the key of a given field's entry\n */\nfunction getFieldEntryKey(node: FieldNode): string {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  return node.alias ? node.alias.value : node.name.value;\n}\n"],"version":3}