53f51ac6aed4e50a5666b6bcd1e938a7
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFieldsWithDirectives = void 0;
const graphql_1 = require("graphql");
function parseDirectiveValue(value) {
    switch (value.kind) {
        case graphql_1.Kind.INT:
            return parseInt(value.value);
        case graphql_1.Kind.FLOAT:
            return parseFloat(value.value);
        case graphql_1.Kind.BOOLEAN:
            return Boolean(value.value);
        case graphql_1.Kind.STRING:
        case graphql_1.Kind.ENUM:
            return value.value;
        case graphql_1.Kind.LIST:
            return value.values.map(v => parseDirectiveValue(v));
        case graphql_1.Kind.OBJECT:
            return value.fields.reduce((prev, v) => ({ ...prev, [v.name.value]: parseDirectiveValue(v.value) }), {});
        case graphql_1.Kind.NULL:
            return null;
        default:
            return null;
    }
}
function getFieldsWithDirectives(documentNode, options = {}) {
    const result = {};
    let selected = ['ObjectTypeDefinition', 'ObjectTypeExtension'];
    if (options.includeInputTypes) {
        selected = [...selected, 'InputObjectTypeDefinition', 'InputObjectTypeExtension'];
    }
    const allTypes = documentNode.definitions.filter(obj => selected.includes(obj.kind));
    for (const type of allTypes) {
        const typeName = type.name.value;
        for (const field of type.fields) {
            if (field.directives && field.directives.length > 0) {
                const fieldName = field.name.value;
                const key = `${typeName}.${fieldName}`;
                const directives = field.directives.map(d => ({
                    name: d.name.value,
                    args: (d.arguments || []).reduce((prev, arg) => ({ ...prev, [arg.name.value]: parseDirectiveValue(arg.value) }), {}),
                }));
                result[key] = directives;
            }
        }
    }
    return result;
}
exports.getFieldsWithDirectives = getFieldsWithDirectives;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvYXJkYXRfMDAwL0d1aWxkL2dyYXBocWwtdG9vbHMvcGFja2FnZXMvdXRpbHMvc3JjL2dldC1maWVsZHMtd2l0aC1kaXJlY3RpdmVzLnRzIiwibWFwcGluZ3MiOiI7OztBQUFBLHFDQVFpQjtBQWtCakIsU0FBUyxtQkFBbUIsQ0FBQyxLQUFnQjtJQUMzQyxRQUFRLEtBQUssQ0FBQyxJQUFJLEVBQUU7UUFDbEIsS0FBSyxjQUFJLENBQUMsR0FBRztZQUNYLE9BQU8sUUFBUSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMvQixLQUFLLGNBQUksQ0FBQyxLQUFLO1lBQ2IsT0FBTyxVQUFVLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2pDLEtBQUssY0FBSSxDQUFDLE9BQU87WUFDZixPQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDOUIsS0FBSyxjQUFJLENBQUMsTUFBTSxDQUFDO1FBQ2pCLEtBQUssY0FBSSxDQUFDLElBQUk7WUFDWixPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUM7UUFDckIsS0FBSyxjQUFJLENBQUMsSUFBSTtZQUNaLE9BQU8sS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZELEtBQUssY0FBSSxDQUFDLE1BQU07WUFDZCxPQUFPLEtBQUssQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLEdBQUcsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzNHLEtBQUssY0FBSSxDQUFDLElBQUk7WUFDWixPQUFPLElBQUksQ0FBQztRQUNkO1lBQ0UsT0FBTyxJQUFJLENBQUM7S0FDZjtBQUNILENBQUM7QUFFRCxTQUFnQix1QkFBdUIsQ0FBQyxZQUEwQixFQUFFLFVBQW1CLEVBQUU7SUFDdkYsTUFBTSxNQUFNLEdBQTZCLEVBQUUsQ0FBQztJQUU1QyxJQUFJLFFBQVEsR0FBRyxDQUFDLHNCQUFzQixFQUFFLHFCQUFxQixDQUFDLENBQUM7SUFFL0QsSUFBSSxPQUFPLENBQUMsaUJBQWlCLEVBQUU7UUFDN0IsUUFBUSxHQUFHLENBQUMsR0FBRyxRQUFRLEVBQUUsMkJBQTJCLEVBQUUsMEJBQTBCLENBQUMsQ0FBQztLQUNuRjtJQUVELE1BQU0sUUFBUSxHQUFHLFlBQVksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQW9CLENBQUM7SUFFeEcsS0FBSyxNQUFNLElBQUksSUFBSSxRQUFRLEVBQUU7UUFDM0IsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7UUFFakMsS0FBSyxNQUFNLEtBQUssSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQy9CLElBQUksS0FBSyxDQUFDLFVBQVUsSUFBSSxLQUFLLENBQUMsVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7Z0JBQ25ELE1BQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO2dCQUNuQyxNQUFNLEdBQUcsR0FBRyxHQUFHLFFBQVEsSUFBSSxTQUFTLEVBQUUsQ0FBQztnQkFDdkMsTUFBTSxVQUFVLEdBQXFCLEtBQUssQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFDOUQsSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSztvQkFDbEIsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLFNBQVMsSUFBSSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQzlCLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLEdBQUcsSUFBSSxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUM5RSxFQUFFLENBQ0g7aUJBQ0YsQ0FBQyxDQUFDLENBQUM7Z0JBRUosTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFVBQVUsQ0FBQzthQUMxQjtTQUNGO0tBQ0Y7SUFFRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBaENELDBEQWdDQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvaG9tZS9hcmRhdF8wMDAvR3VpbGQvZ3JhcGhxbC10b29scy9wYWNrYWdlcy91dGlscy9zcmMvZ2V0LWZpZWxkcy13aXRoLWRpcmVjdGl2ZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRG9jdW1lbnROb2RlLFxuICBPYmplY3RUeXBlRGVmaW5pdGlvbk5vZGUsXG4gIE9iamVjdFR5cGVFeHRlbnNpb25Ob2RlLFxuICBJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uTm9kZSxcbiAgSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uTm9kZSxcbiAgVmFsdWVOb2RlLFxuICBLaW5kLFxufSBmcm9tICdncmFwaHFsJztcblxuZXhwb3J0IHR5cGUgRGlyZWN0aXZlQXJncyA9IHsgW25hbWU6IHN0cmluZ106IGFueSB9O1xuZXhwb3J0IHR5cGUgRGlyZWN0aXZlVXNhZ2UgPSB7IG5hbWU6IHN0cmluZzsgYXJnczogRGlyZWN0aXZlQXJncyB9O1xuZXhwb3J0IHR5cGUgVHlwZUFuZEZpZWxkVG9EaXJlY3RpdmVzID0ge1xuICBbdHlwZUFuZEZpZWxkOiBzdHJpbmddOiBEaXJlY3RpdmVVc2FnZVtdO1xufTtcblxuaW50ZXJmYWNlIE9wdGlvbnMge1xuICBpbmNsdWRlSW5wdXRUeXBlcz86IGJvb2xlYW47XG59XG5cbnR5cGUgU2VsZWN0ZWROb2RlcyA9XG4gIHwgT2JqZWN0VHlwZURlZmluaXRpb25Ob2RlXG4gIHwgT2JqZWN0VHlwZUV4dGVuc2lvbk5vZGVcbiAgfCBJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uTm9kZVxuICB8IElucHV0T2JqZWN0VHlwZUV4dGVuc2lvbk5vZGU7XG5cbmZ1bmN0aW9uIHBhcnNlRGlyZWN0aXZlVmFsdWUodmFsdWU6IFZhbHVlTm9kZSk6IGFueSB7XG4gIHN3aXRjaCAodmFsdWUua2luZCkge1xuICAgIGNhc2UgS2luZC5JTlQ6XG4gICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUudmFsdWUpO1xuICAgIGNhc2UgS2luZC5GTE9BVDpcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlLnZhbHVlKTtcbiAgICBjYXNlIEtpbmQuQk9PTEVBTjpcbiAgICAgIHJldHVybiBCb29sZWFuKHZhbHVlLnZhbHVlKTtcbiAgICBjYXNlIEtpbmQuU1RSSU5HOlxuICAgIGNhc2UgS2luZC5FTlVNOlxuICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlO1xuICAgIGNhc2UgS2luZC5MSVNUOlxuICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlcy5tYXAodiA9PiBwYXJzZURpcmVjdGl2ZVZhbHVlKHYpKTtcbiAgICBjYXNlIEtpbmQuT0JKRUNUOlxuICAgICAgcmV0dXJuIHZhbHVlLmZpZWxkcy5yZWR1Y2UoKHByZXYsIHYpID0+ICh7IC4uLnByZXYsIFt2Lm5hbWUudmFsdWVdOiBwYXJzZURpcmVjdGl2ZVZhbHVlKHYudmFsdWUpIH0pLCB7fSk7XG4gICAgY2FzZSBLaW5kLk5VTEw6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZpZWxkc1dpdGhEaXJlY3RpdmVzKGRvY3VtZW50Tm9kZTogRG9jdW1lbnROb2RlLCBvcHRpb25zOiBPcHRpb25zID0ge30pOiBUeXBlQW5kRmllbGRUb0RpcmVjdGl2ZXMge1xuICBjb25zdCByZXN1bHQ6IFR5cGVBbmRGaWVsZFRvRGlyZWN0aXZlcyA9IHt9O1xuXG4gIGxldCBzZWxlY3RlZCA9IFsnT2JqZWN0VHlwZURlZmluaXRpb24nLCAnT2JqZWN0VHlwZUV4dGVuc2lvbiddO1xuXG4gIGlmIChvcHRpb25zLmluY2x1ZGVJbnB1dFR5cGVzKSB7XG4gICAgc2VsZWN0ZWQgPSBbLi4uc2VsZWN0ZWQsICdJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uJywgJ0lucHV0T2JqZWN0VHlwZUV4dGVuc2lvbiddO1xuICB9XG5cbiAgY29uc3QgYWxsVHlwZXMgPSBkb2N1bWVudE5vZGUuZGVmaW5pdGlvbnMuZmlsdGVyKG9iaiA9PiBzZWxlY3RlZC5pbmNsdWRlcyhvYmoua2luZCkpIGFzIFNlbGVjdGVkTm9kZXNbXTtcblxuICBmb3IgKGNvbnN0IHR5cGUgb2YgYWxsVHlwZXMpIHtcbiAgICBjb25zdCB0eXBlTmFtZSA9IHR5cGUubmFtZS52YWx1ZTtcblxuICAgIGZvciAoY29uc3QgZmllbGQgb2YgdHlwZS5maWVsZHMpIHtcbiAgICAgIGlmIChmaWVsZC5kaXJlY3RpdmVzICYmIGZpZWxkLmRpcmVjdGl2ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lLnZhbHVlO1xuICAgICAgICBjb25zdCBrZXkgPSBgJHt0eXBlTmFtZX0uJHtmaWVsZE5hbWV9YDtcbiAgICAgICAgY29uc3QgZGlyZWN0aXZlczogRGlyZWN0aXZlVXNhZ2VbXSA9IGZpZWxkLmRpcmVjdGl2ZXMubWFwKGQgPT4gKHtcbiAgICAgICAgICBuYW1lOiBkLm5hbWUudmFsdWUsXG4gICAgICAgICAgYXJnczogKGQuYXJndW1lbnRzIHx8IFtdKS5yZWR1Y2UoXG4gICAgICAgICAgICAocHJldiwgYXJnKSA9PiAoeyAuLi5wcmV2LCBbYXJnLm5hbWUudmFsdWVdOiBwYXJzZURpcmVjdGl2ZVZhbHVlKGFyZy52YWx1ZSkgfSksXG4gICAgICAgICAgICB7fVxuICAgICAgICAgICksXG4gICAgICAgIH0pKTtcblxuICAgICAgICByZXN1bHRba2V5XSA9IGRpcmVjdGl2ZXM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiJdLCJ2ZXJzaW9uIjozfQ==