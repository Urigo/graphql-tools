{"file":"/home/ardat_000/Guild/graphql-tools/packages/schema/src/addResolversToSchema.ts","mappings":"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","names":[],"sources":["/home/ardat_000/Guild/graphql-tools/packages/schema/src/addResolversToSchema.ts"],"sourcesContent":["import {\n  GraphQLEnumType,\n  GraphQLSchema,\n  isSchema,\n  GraphQLScalarType,\n  GraphQLUnionType,\n  GraphQLInterfaceType,\n  GraphQLFieldConfig,\n  GraphQLObjectType,\n  isSpecifiedScalarType,\n  GraphQLFieldResolver,\n  isScalarType,\n  isEnumType,\n  isUnionType,\n  isInterfaceType,\n  isObjectType,\n  GraphQLField,\n} from 'graphql';\n\nimport {\n  IResolvers,\n  IResolverValidationOptions,\n  IAddResolversToSchemaOptions,\n  mapSchema,\n  MapperKind,\n  forEachDefaultValue,\n  serializeInputValue,\n  healSchema,\n  parseInputValue,\n  forEachField,\n} from '@graphql-tools/utils';\n\nimport { checkForResolveTypeResolver } from './checkForResolveTypeResolver';\nimport { extendResolversFromInterfaces } from './extendResolversFromInterfaces';\n\nexport function addResolversToSchema(\n  schemaOrOptions: GraphQLSchema | IAddResolversToSchemaOptions,\n  legacyInputResolvers?: IResolvers,\n  legacyInputValidationOptions?: IResolverValidationOptions\n): GraphQLSchema {\n  const options: IAddResolversToSchemaOptions = isSchema(schemaOrOptions)\n    ? {\n        schema: schemaOrOptions,\n        resolvers: legacyInputResolvers,\n        resolverValidationOptions: legacyInputValidationOptions,\n      }\n    : schemaOrOptions;\n\n  let {\n    schema,\n    resolvers: inputResolvers,\n    defaultFieldResolver,\n    resolverValidationOptions = {},\n    inheritResolversFromInterfaces = false,\n    updateResolversInPlace = false,\n  } = options;\n\n  const { requireResolversToMatchSchema = 'error', requireResolversForResolveType } = resolverValidationOptions;\n\n  const resolvers = inheritResolversFromInterfaces\n    ? extendResolversFromInterfaces(schema, inputResolvers)\n    : inputResolvers;\n\n  Object.keys(resolvers).forEach(typeName => {\n    const resolverValue = resolvers[typeName];\n    const resolverType = typeof resolverValue;\n\n    if (typeName === '__schema') {\n      if (resolverType !== 'function') {\n        throw new Error(\n          `\"${typeName}\" defined in resolvers, but has invalid value \"${\n            (resolverValue as unknown) as string\n          }\". A schema resolver's value must be of type object or function.`\n        );\n      }\n    } else {\n      if (resolverType !== 'object') {\n        throw new Error(\n          `\"${typeName}\" defined in resolvers, but has invalid value \"${\n            (resolverValue as unknown) as string\n          }\". The resolver's value must be of type object.`\n        );\n      }\n\n      const type = schema.getType(typeName);\n\n      if (type == null) {\n        if (requireResolversToMatchSchema === 'ignore') {\n          return;\n        }\n\n        throw new Error(`\"${typeName}\" defined in resolvers, but not in schema`);\n      } else if (isSpecifiedScalarType(type)) {\n        // allow -- without recommending -- overriding of specified scalar types\n        Object.keys(resolverValue).forEach(fieldName => {\n          if (fieldName.startsWith('__')) {\n            type[fieldName.substring(2)] = resolverValue[fieldName];\n          } else {\n            type[fieldName] = resolverValue[fieldName];\n          }\n        });\n      } else if (isEnumType(type)) {\n        const values = type.getValues();\n\n        Object.keys(resolverValue).forEach(fieldName => {\n          if (\n            !fieldName.startsWith('__') &&\n            !values.some(value => value.name === fieldName) &&\n            requireResolversToMatchSchema &&\n            requireResolversToMatchSchema !== 'ignore'\n          ) {\n            throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);\n          }\n        });\n      } else if (isUnionType(type)) {\n        Object.keys(resolverValue).forEach(fieldName => {\n          if (\n            !fieldName.startsWith('__') &&\n            requireResolversToMatchSchema &&\n            requireResolversToMatchSchema !== 'ignore'\n          ) {\n            throw new Error(\n              `${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`\n            );\n          }\n        });\n      } else if (isObjectType(type) || isInterfaceType(type)) {\n        Object.keys(resolverValue).forEach(fieldName => {\n          if (!fieldName.startsWith('__')) {\n            const fields = type.getFields();\n            const field = fields[fieldName];\n\n            if (field == null && requireResolversToMatchSchema && requireResolversToMatchSchema !== 'ignore') {\n              throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);\n            }\n\n            const fieldResolve = resolverValue[fieldName];\n            if (typeof fieldResolve !== 'function' && typeof fieldResolve !== 'object') {\n              throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);\n            }\n          }\n        });\n      }\n    }\n  });\n\n  schema = updateResolversInPlace\n    ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver)\n    : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver);\n\n  if (requireResolversForResolveType || requireResolversForResolveType !== 'ignore') {\n    checkForResolveTypeResolver(schema, requireResolversForResolveType);\n  }\n\n  return schema;\n}\n\nfunction addResolversToExistingSchema(\n  schema: GraphQLSchema,\n  resolvers: IResolvers,\n  defaultFieldResolver: GraphQLFieldResolver<any, any>\n): GraphQLSchema {\n  const typeMap = schema.getTypeMap();\n  Object.keys(resolvers).forEach(typeName => {\n    if (typeName !== '__schema') {\n      const type = schema.getType(typeName);\n      const resolverValue = resolvers[typeName];\n\n      if (isScalarType(type)) {\n        Object.keys(resolverValue).forEach(fieldName => {\n          if (fieldName.startsWith('__')) {\n            type[fieldName.substring(2)] = resolverValue[fieldName];\n          } else if (fieldName === 'astNode' && type.astNode != null) {\n            type.astNode = {\n              ...type.astNode,\n              description: (resolverValue as GraphQLScalarType)?.astNode?.description ?? type.astNode.description,\n              directives: (type.astNode.directives ?? []).concat(\n                (resolverValue as GraphQLScalarType)?.astNode?.directives ?? []\n              ),\n            };\n          } else if (fieldName === 'extensionASTNodes' && type.extensionASTNodes != null) {\n            type.extensionASTNodes = ([] ?? type.extensionASTNodes).concat(\n              (resolverValue as GraphQLScalarType)?.extensionASTNodes ?? []\n            );\n          } else if (\n            fieldName === 'extensions' &&\n            type.extensions != null &&\n            (resolverValue as GraphQLScalarType).extensions != null\n          ) {\n            type.extensions = Object.assign({}, type.extensions, (resolverValue as GraphQLScalarType).extensions);\n          } else {\n            type[fieldName] = resolverValue[fieldName];\n          }\n        });\n      } else if (isEnumType(type)) {\n        const config = type.toConfig();\n        const enumValueConfigMap = config.values;\n\n        Object.keys(resolverValue).forEach(fieldName => {\n          if (fieldName.startsWith('__')) {\n            config[fieldName.substring(2)] = resolverValue[fieldName];\n          } else if (fieldName === 'astNode' && config.astNode != null) {\n            config.astNode = {\n              ...config.astNode,\n              description: (resolverValue as GraphQLScalarType)?.astNode?.description ?? config.astNode.description,\n              directives: (config.astNode.directives ?? []).concat(\n                (resolverValue as GraphQLEnumType)?.astNode?.directives ?? []\n              ),\n            };\n          } else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.concat(\n              (resolverValue as GraphQLEnumType)?.extensionASTNodes ?? []\n            );\n          } else if (\n            fieldName === 'extensions' &&\n            type.extensions != null &&\n            (resolverValue as GraphQLEnumType).extensions != null\n          ) {\n            type.extensions = Object.assign({}, type.extensions, (resolverValue as GraphQLEnumType).extensions);\n          } else if (enumValueConfigMap[fieldName]) {\n            enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n          }\n        });\n\n        typeMap[typeName] = new GraphQLEnumType(config);\n      } else if (isUnionType(type)) {\n        Object.keys(resolverValue).forEach(fieldName => {\n          if (fieldName.startsWith('__')) {\n            type[fieldName.substring(2)] = resolverValue[fieldName];\n          }\n        });\n      } else if (isObjectType(type) || isInterfaceType(type)) {\n        Object.keys(resolverValue).forEach(fieldName => {\n          if (fieldName.startsWith('__')) {\n            // this is for isTypeOf and resolveType and all the other stuff.\n            type[fieldName.substring(2)] = resolverValue[fieldName];\n            return;\n          }\n\n          const fields = type.getFields();\n          const field = fields[fieldName];\n\n          if (field != null) {\n            const fieldResolve = resolverValue[fieldName];\n            if (typeof fieldResolve === 'function') {\n              // for convenience. Allows shorter syntax in resolver definition file\n              field.resolve = fieldResolve;\n            } else {\n              setFieldProperties(field, fieldResolve);\n            }\n          }\n        });\n      }\n    }\n  });\n\n  // serialize all default values prior to healing fields with new scalar/enum types.\n  forEachDefaultValue(schema, serializeInputValue);\n  // schema may have new scalar/enum types that require healing\n  healSchema(schema);\n  // reparse all default values with new parsing functions.\n  forEachDefaultValue(schema, parseInputValue);\n\n  if (defaultFieldResolver != null) {\n    forEachField(schema, field => {\n      if (!field.resolve) {\n        field.resolve = defaultFieldResolver;\n      }\n    });\n  }\n\n  return schema;\n}\n\nfunction createNewSchemaWithResolvers(\n  schema: GraphQLSchema,\n  resolvers: IResolvers,\n  defaultFieldResolver: GraphQLFieldResolver<any, any>\n): GraphQLSchema {\n  schema = mapSchema(schema, {\n    [MapperKind.SCALAR_TYPE]: type => {\n      const config = type.toConfig();\n      const resolverValue = resolvers[type.name];\n      if (!isSpecifiedScalarType(type) && resolverValue != null) {\n        Object.keys(resolverValue).forEach(fieldName => {\n          if (fieldName.startsWith('__')) {\n            config[fieldName.substring(2)] = resolverValue[fieldName];\n          } else if (fieldName === 'astNode' && config.astNode != null) {\n            config.astNode = {\n              ...config.astNode,\n              description: (resolverValue as GraphQLScalarType)?.astNode?.description ?? config.astNode.description,\n              directives: (config.astNode.directives ?? []).concat(\n                (resolverValue as GraphQLScalarType)?.astNode?.directives ?? []\n              ),\n            };\n          } else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.concat(\n              (resolverValue as GraphQLScalarType)?.extensionASTNodes ?? []\n            );\n          } else if (\n            fieldName === 'extensions' &&\n            config.extensions != null &&\n            (resolverValue as GraphQLScalarType).extensions != null\n          ) {\n            config.extensions = Object.assign({}, type.extensions, (resolverValue as GraphQLScalarType).extensions);\n          } else {\n            config[fieldName] = resolverValue[fieldName];\n          }\n        });\n\n        return new GraphQLScalarType(config);\n      }\n    },\n    [MapperKind.ENUM_TYPE]: type => {\n      const resolverValue = resolvers[type.name];\n\n      const config = type.toConfig();\n      const enumValueConfigMap = config.values;\n\n      if (resolverValue != null) {\n        Object.keys(resolverValue).forEach(fieldName => {\n          if (fieldName.startsWith('__')) {\n            config[fieldName.substring(2)] = resolverValue[fieldName];\n          } else if (fieldName === 'astNode' && config.astNode != null) {\n            config.astNode = {\n              ...config.astNode,\n              description: (resolverValue as GraphQLScalarType)?.astNode?.description ?? config.astNode.description,\n              directives: (config.astNode.directives ?? []).concat(\n                (resolverValue as GraphQLEnumType)?.astNode?.directives ?? []\n              ),\n            };\n          } else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.concat(\n              (resolverValue as GraphQLEnumType)?.extensionASTNodes ?? []\n            );\n          } else if (\n            fieldName === 'extensions' &&\n            config.extensions != null &&\n            (resolverValue as GraphQLEnumType).extensions != null\n          ) {\n            config.extensions = Object.assign({}, type.extensions, (resolverValue as GraphQLEnumType).extensions);\n          } else if (enumValueConfigMap[fieldName]) {\n            enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n          }\n        });\n\n        return new GraphQLEnumType(config);\n      }\n    },\n    [MapperKind.UNION_TYPE]: type => {\n      const resolverValue = resolvers[type.name];\n\n      if (resolverValue != null) {\n        const config = type.toConfig();\n        Object.keys(resolverValue).forEach(fieldName => {\n          if (fieldName.startsWith('__')) {\n            config[fieldName.substring(2)] = resolverValue[fieldName];\n          }\n        });\n\n        return new GraphQLUnionType(config);\n      }\n    },\n    [MapperKind.OBJECT_TYPE]: type => {\n      const resolverValue = resolvers[type.name];\n      if (resolverValue != null) {\n        const config = type.toConfig();\n\n        Object.keys(resolverValue).forEach(fieldName => {\n          if (fieldName.startsWith('__')) {\n            config[fieldName.substring(2)] = resolverValue[fieldName];\n          }\n        });\n\n        return new GraphQLObjectType(config);\n      }\n    },\n    [MapperKind.INTERFACE_TYPE]: type => {\n      const resolverValue = resolvers[type.name];\n      if (resolverValue != null) {\n        const config = type.toConfig();\n\n        Object.keys(resolverValue).forEach(fieldName => {\n          if (fieldName.startsWith('__')) {\n            config[fieldName.substring(2)] = resolverValue[fieldName];\n          }\n        });\n\n        return new GraphQLInterfaceType(config);\n      }\n    },\n    [MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {\n      const resolverValue = resolvers[typeName];\n\n      if (resolverValue != null) {\n        const fieldResolve = resolverValue[fieldName];\n        if (fieldResolve != null) {\n          const newFieldConfig = { ...fieldConfig };\n          if (typeof fieldResolve === 'function') {\n            // for convenience. Allows shorter syntax in resolver definition file\n            newFieldConfig.resolve = fieldResolve;\n          } else {\n            setFieldProperties(newFieldConfig, fieldResolve);\n          }\n          return newFieldConfig;\n        }\n      }\n    },\n  });\n\n  if (defaultFieldResolver != null) {\n    schema = mapSchema(schema, {\n      [MapperKind.OBJECT_FIELD]: fieldConfig => ({\n        ...fieldConfig,\n        resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver,\n      }),\n    });\n  }\n\n  return schema;\n}\n\nfunction setFieldProperties(\n  field: GraphQLField<any, any> | GraphQLFieldConfig<any, any>,\n  propertiesObj: Record<string, any>\n) {\n  Object.keys(propertiesObj).forEach(propertyName => {\n    field[propertyName] = propertiesObj[propertyName];\n  });\n}\n"],"version":3}