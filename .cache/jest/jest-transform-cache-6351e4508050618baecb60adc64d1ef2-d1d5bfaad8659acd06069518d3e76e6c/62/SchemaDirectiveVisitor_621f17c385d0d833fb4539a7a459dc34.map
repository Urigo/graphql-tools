{"file":"/home/ardat_000/Guild/graphql-tools/packages/utils/src/SchemaDirectiveVisitor.ts","mappings":"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","names":[],"sources":["/home/ardat_000/Guild/graphql-tools/packages/utils/src/SchemaDirectiveVisitor.ts"],"sourcesContent":["import {\n  GraphQLDirective,\n  GraphQLSchema,\n  DirectiveLocationEnum,\n  TypeSystemExtensionNode,\n  valueFromASTUntyped,\n} from 'graphql';\n\nimport { VisitableSchemaType } from './Interfaces';\n\nimport { SchemaVisitor } from './SchemaVisitor';\nimport { visitSchema } from './visitSchema';\nimport { getArgumentValues } from './getArgumentValues';\n\n// This class represents a reusable implementation of a @directive that may\n// appear in a GraphQL schema written in Schema Definition Language.\n//\n// By overriding one or more visit{Object,Union,...} methods, a subclass\n// registers interest in certain schema types, such as GraphQLObjectType,\n// GraphQLUnionType, etc. When SchemaDirectiveVisitor.visitSchemaDirectives is\n// called with a GraphQLSchema object and a map of visitor subclasses, the\n// overridden methods of those subclasses allow the visitors to obtain\n// references to any type objects that have @directives attached to them,\n// enabling visitors to inspect or modify the schema as appropriate.\n//\n// For example, if a directive called @rest(url: \"...\") appears after a field\n// definition, a SchemaDirectiveVisitor subclass could provide meaning to that\n// directive by overriding the visitFieldDefinition method (which receives a\n// GraphQLField parameter), and then the body of that visitor method could\n// manipulate the field's resolver function to fetch data from a REST endpoint\n// described by the url argument passed to the @rest directive:\n//\n//   const typeDefs = `\n//   type Query {\n//     people: [Person] @rest(url: \"/api/v1/people\")\n//   }`;\n//\n//   const schema = makeExecutableSchema({ typeDefs });\n//\n//   SchemaDirectiveVisitor.visitSchemaDirectives(schema, {\n//     rest: class extends SchemaDirectiveVisitor {\n//       public visitFieldDefinition(field: GraphQLField<any, any>) {\n//         const { url } = this.args;\n//         field.resolve = () => fetch(url);\n//       }\n//     }\n//   });\n//\n// The subclass in this example is defined as an anonymous class expression,\n// for brevity. A truly reusable SchemaDirectiveVisitor would most likely be\n// defined in a library using a named class declaration, and then exported for\n// consumption by other modules and packages.\n//\n// See below for a complete list of overridable visitor methods, their\n// parameter types, and more details about the properties exposed by instances\n// of the SchemaDirectiveVisitor class.\n\nexport class SchemaDirectiveVisitor<TArgs = any, TContext = any> extends SchemaVisitor {\n  // The name of the directive this visitor is allowed to visit (that is, the\n  // identifier that appears after the @ character in the schema). Note that\n  // this property is per-instance rather than static because subclasses of\n  // SchemaDirectiveVisitor can be instantiated multiple times to visit\n  // directives of different names. In other words, SchemaDirectiveVisitor\n  // implementations are effectively anonymous, and it's up to the caller of\n  // SchemaDirectiveVisitor.visitSchemaDirectives to assign names to them.\n  public name: string;\n\n  // A map from parameter names to argument values, as obtained from a\n  // specific occurrence of a @directive(arg1: value1, arg2: value2, ...) in\n  // the schema. Visitor methods may refer to this object via this.args.\n  public args: TArgs;\n\n  // A reference to the type object that this visitor was created to visit.\n  public visitedType: VisitableSchemaType;\n\n  // A shared object that will be available to all visitor instances via\n  // this.context. Callers of visitSchemaDirectives can provide their own\n  // object, or just use the default empty object.\n  public context: TContext;\n\n  // Override this method to return a custom GraphQLDirective (or modify one\n  // already present in the schema) to enforce argument types, provide default\n  // argument values, or specify schema locations where this @directive may\n  // appear. By default, any declaration found in the schema will be returned.\n  public static getDirectiveDeclaration(\n    directiveName: string,\n    schema: GraphQLSchema\n  ): GraphQLDirective | null | undefined {\n    return schema.getDirective(directiveName);\n  }\n\n  // Call SchemaDirectiveVisitor.visitSchemaDirectives to visit every\n  // @directive in the schema and create an appropriate SchemaDirectiveVisitor\n  // instance to visit the object decorated by the @directive.\n  public static visitSchemaDirectives(\n    schema: GraphQLSchema,\n    // The keys of this object correspond to directive names as they appear\n    // in the schema, and the values should be subclasses (not instances!)\n    // of the SchemaDirectiveVisitor class. This distinction is important\n    // because a new SchemaDirectiveVisitor instance will be created each\n    // time a matching directive is found in the schema AST, with arguments\n    // and other metadata specific to that occurrence. To help prevent the\n    // mistake of passing instances, the SchemaDirectiveVisitor constructor\n    // method is marked as protected.\n    directiveVisitors: Record<string, SchemaDirectiveVisitorClass>,\n    // Optional context object that will be available to all visitor instances\n    // via this.context. Defaults to an empty null-prototype object.\n    context: Record<string, any> = Object.create(null),\n    // The visitSchemaDirectives method returns a map from directive names to\n    // lists of SchemaDirectiveVisitors created while visiting the schema.\n    pathToDirectivesInExtensions = ['directives']\n  ): Record<string, Array<SchemaDirectiveVisitor>> {\n    // If the schema declares any directives for public consumption, record\n    // them here so that we can properly coerce arguments when/if we encounter\n    // an occurrence of the directive while walking the schema below.\n    const declaredDirectives = this.getDeclaredDirectives(schema, directiveVisitors);\n\n    // Map from directive names to lists of SchemaDirectiveVisitor instances\n    // created while visiting the schema.\n    const createdVisitors: Record<string, Array<any>> = Object.keys(directiveVisitors).reduce(\n      (prev, item) => ({\n        ...prev,\n        [item]: [],\n      }),\n      {}\n    );\n\n    const directiveVisitorMap: Record<string, typeof SchemaDirectiveVisitor> = Object.entries(directiveVisitors).reduce(\n      (prev, [key, value]) => ({\n        ...prev,\n        [key]: value,\n      }),\n      {}\n    );\n\n    function visitorSelector(type: VisitableSchemaType, methodName: string): Array<SchemaDirectiveVisitor> {\n      const directivesInExtensions = pathToDirectivesInExtensions.reduce(\n        (acc, pathSegment) => (acc == null ? acc : acc[pathSegment]),\n        type?.extensions\n      );\n\n      const directives: Record<string, Array<any>> = Object.create(null);\n\n      if (directivesInExtensions != null) {\n        Object.entries(directivesInExtensions).forEach(([directiveName, directiveValue]) => {\n          if (!directives[directiveName]) {\n            directives[directiveName] = [directiveValue];\n          } else {\n            directives[directiveName].push([directiveValue]);\n          }\n        });\n      } else {\n        let directiveNodes = type?.astNode?.directives ?? [];\n\n        const extensionASTNodes: ReadonlyArray<TypeSystemExtensionNode> = (type as {\n          extensionASTNodes?: Array<TypeSystemExtensionNode>;\n        }).extensionASTNodes;\n\n        if (extensionASTNodes != null) {\n          extensionASTNodes.forEach(extensionASTNode => {\n            if (extensionASTNode.directives != null) {\n              directiveNodes = directiveNodes.concat(extensionASTNode.directives);\n            }\n          });\n        }\n\n        directiveNodes.forEach(directiveNode => {\n          const directiveName = directiveNode.name.value;\n\n          const decl = declaredDirectives[directiveName];\n          let args: Record<string, any>;\n\n          if (decl != null) {\n            // If this directive was explicitly declared, use the declared\n            // argument types (and any default values) to check, coerce, and/or\n            // supply default values for the given arguments.\n            args = getArgumentValues(decl, directiveNode);\n          } else {\n            // If this directive was not explicitly declared, just convert the\n            // argument nodes to their corresponding JavaScript values.\n            args = Object.create(null);\n            if (directiveNode.arguments != null) {\n              directiveNode.arguments.forEach(arg => {\n                args[arg.name.value] = valueFromASTUntyped(arg.value);\n              });\n            }\n          }\n\n          if (!directives[directiveName]) {\n            directives[directiveName] = [args];\n          } else {\n            directives[directiveName].push(args);\n          }\n        });\n      }\n\n      const visitors: Array<SchemaDirectiveVisitor> = [];\n\n      Object.entries(directives).forEach(([directiveName, directiveValues]) => {\n        if (!(directiveName in directiveVisitorMap)) {\n          return;\n        }\n\n        const VisitorClass = directiveVisitorMap[directiveName];\n\n        // Avoid creating visitor objects if visitorClass does not override\n        // the visitor method named by methodName.\n        if (!VisitorClass.implementsVisitorMethod(methodName)) {\n          return;\n        }\n\n        directiveValues.forEach(directiveValue => {\n          // As foretold in comments near the top of the visitSchemaDirectives\n          // method, this is where instances of the SchemaDirectiveVisitor class\n          // get created and assigned names. While subclasses could override the\n          // constructor method, the constructor is marked as protected, so\n          // these are the only arguments that will ever be passed.\n          visitors.push(\n            new VisitorClass({\n              name: directiveName,\n              args: directiveValue,\n              visitedType: type,\n              schema,\n              context,\n            })\n          );\n        });\n      });\n\n      if (visitors.length > 0) {\n        visitors.forEach(visitor => {\n          createdVisitors[visitor.name].push(visitor);\n        });\n      }\n\n      return visitors;\n    }\n\n    visitSchema(schema, visitorSelector);\n\n    return createdVisitors;\n  }\n\n  protected static getDeclaredDirectives(\n    schema: GraphQLSchema,\n    directiveVisitors: Record<string, SchemaDirectiveVisitorClass>\n  ): Record<string, GraphQLDirective> {\n    const declaredDirectives: Record<string, GraphQLDirective> = schema.getDirectives().reduce(\n      (prev, curr) => ({\n        ...prev,\n        [curr.name]: curr,\n      }),\n      {}\n    );\n    // If the visitor subclass overrides getDirectiveDeclaration, and it\n    // returns a non-null GraphQLDirective, use that instead of any directive\n    // declared in the schema itself. Reasoning: if a SchemaDirectiveVisitor\n    // goes to the trouble of implementing getDirectiveDeclaration, it should\n    // be able to rely on that implementation.\n    Object.entries(directiveVisitors).forEach(([directiveName, visitorClass]) => {\n      const decl = visitorClass.getDirectiveDeclaration(directiveName, schema);\n      if (decl != null) {\n        declaredDirectives[directiveName] = decl;\n      }\n    });\n\n    Object.entries(declaredDirectives).forEach(([name, decl]) => {\n      if (!(name in directiveVisitors)) {\n        // SchemaDirectiveVisitors.visitSchemaDirectives might be called\n        // multiple times with partial directiveVisitors maps, so it's not\n        // necessarily an error for directiveVisitors to be missing an\n        // implementation of a directive that was declared in the schema.\n        return;\n      }\n      const visitorClass = directiveVisitors[name];\n\n      decl.locations.forEach(loc => {\n        const visitorMethodName = directiveLocationToVisitorMethodName(loc);\n        if (\n          SchemaVisitor.implementsVisitorMethod(visitorMethodName) &&\n          !visitorClass.implementsVisitorMethod(visitorMethodName)\n        ) {\n          // While visitor subclasses may implement extra visitor methods,\n          // it's definitely a mistake if the GraphQLDirective declares itself\n          // applicable to certain schema locations, and the visitor subclass\n          // does not implement all the corresponding methods.\n          throw new Error(`SchemaDirectiveVisitor for @${name} must implement ${visitorMethodName} method`);\n        }\n      });\n    });\n\n    return declaredDirectives;\n  }\n\n  // Mark the constructor protected to enforce passing SchemaDirectiveVisitor\n  // subclasses (not instances) to visitSchemaDirectives.\n  protected constructor(config: {\n    name: string;\n    args: TArgs;\n    visitedType: VisitableSchemaType;\n    schema: GraphQLSchema;\n    context: TContext;\n  }) {\n    super();\n    this.name = config.name;\n    this.args = config.args;\n    this.visitedType = config.visitedType;\n    this.schema = config.schema;\n    this.context = config.context;\n  }\n}\n\n// Convert a string like \"FIELD_DEFINITION\" to \"visitFieldDefinition\".\nfunction directiveLocationToVisitorMethodName(loc: DirectiveLocationEnum) {\n  return (\n    'visit' +\n    loc.replace(/([^_]*)_?/g, (_wholeMatch, part: string) => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())\n  );\n}\n\nexport type SchemaDirectiveVisitorClass = typeof SchemaDirectiveVisitor;\n"],"version":3}