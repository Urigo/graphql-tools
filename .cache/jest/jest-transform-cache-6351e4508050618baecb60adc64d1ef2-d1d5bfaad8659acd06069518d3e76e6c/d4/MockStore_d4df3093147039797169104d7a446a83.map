{"file":"/home/ardat_000/Guild/graphql-tools/packages/mock/src/MockStore.ts","mappings":"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","names":[],"sources":["/home/ardat_000/Guild/graphql-tools/packages/mock/src/MockStore.ts"],"sourcesContent":["import {\n  GraphQLSchema,\n  isObjectType,\n  isScalarType,\n  getNullableType,\n  isListType,\n  GraphQLOutputType,\n  isEnumType,\n  isAbstractType,\n  isCompositeType,\n  isNullableType,\n  isInterfaceType,\n} from 'graphql';\nimport { assertIsDefined } from 'ts-is-defined';\nimport stringify from 'fast-json-stable-stringify';\n\nimport {\n  IMockStore,\n  GetArgs,\n  SetArgs,\n  isRef,\n  assertIsRef,\n  Ref,\n  isRecord,\n  TypePolicy,\n  IMocks,\n  KeyTypeConstraints,\n  IScalarMock,\n  ITypeMock,\n} from './types';\nimport { uuidv4, randomListLength, takeRandom, makeRef } from './utils';\nimport { deepResolveMockList, isMockList } from './MockList';\n\nexport const defaultMocks = {\n  Int: () => Math.round(Math.random() * 200) - 100,\n  Float: () => Math.random() * 200 - 100,\n  String: () => 'Hello World',\n  Boolean: () => Math.random() > 0.5,\n  ID: () => uuidv4(),\n};\n\ntype Entity = {\n  [key: string]: unknown;\n};\n\nexport class MockStore implements IMockStore {\n  public schema: GraphQLSchema;\n  private mocks: IMocks;\n  private typePolicies: {\n    [typeName: string]: TypePolicy;\n  };\n\n  private store: { [typeName: string]: { [key: string]: Entity } } = {};\n\n  constructor({\n    schema,\n    mocks,\n    typePolicies,\n  }: {\n    schema: GraphQLSchema;\n    mocks?: IMocks;\n    typePolicies?: {\n      [typeName: string]: TypePolicy;\n    };\n  }) {\n    this.schema = schema;\n    this.mocks = { ...defaultMocks, ...mocks };\n    this.typePolicies = typePolicies || {};\n  }\n\n  get<KeyT extends KeyTypeConstraints = string, ReturnKeyT extends KeyTypeConstraints = string>(\n    _typeName: string | Ref<KeyT> | GetArgs<KeyT>,\n    _key?: KeyT | { [fieldName: string]: any } | string | string[],\n    _fieldName?: string | string[] | { [fieldName: string]: any } | string | { [argName: string]: any },\n    _fieldArgs?: string | { [argName: string]: any }\n  ): unknown | Ref<ReturnKeyT> {\n    if (typeof _typeName !== 'string') {\n      if (_key === undefined) {\n        if (isRef<KeyT>(_typeName)) {\n          throw new Error(\"Can't provide a ref as first argument and no other argument\");\n        }\n        // get({...})\n        return this.getImpl(_typeName);\n      } else {\n        assertIsRef<KeyT>(_typeName);\n        const { $ref } = _typeName;\n\n        // arguments shift\n        _fieldArgs = _fieldName;\n        _fieldName = _key as string | string[];\n        _key = $ref.key;\n        _typeName = $ref.typeName;\n      }\n    }\n\n    const args: GetArgs<KeyT> = {\n      typeName: _typeName,\n    };\n\n    if (isRecord(_key) || _key === undefined) {\n      // get('User', { name: 'Alex'})\n      args.defaultValue = _key;\n      return this.getImpl(args);\n    }\n\n    args.key = _key as KeyT;\n\n    if (Array.isArray(_fieldName) && _fieldName.length === 1) {\n      _fieldName = _fieldName[0];\n    }\n\n    if (typeof _fieldName !== 'string' && !Array.isArray(_fieldName)) {\n      // get('User', 'me', { name: 'Alex'})\n      args.defaultValue = _fieldName;\n      return this.getImpl(args);\n    }\n\n    if (Array.isArray(_fieldName)) {\n      // get('User', 'me', ['father', 'name'])\n      const ref: unknown = this.get(_typeName, _key, _fieldName[0], _fieldArgs);\n      assertIsRef(ref);\n\n      return this.get(ref.$ref.typeName, ref.$ref.key, _fieldName.slice(1, _fieldName.length));\n    }\n\n    // get('User', 'me', 'name'...);\n    args.fieldName = _fieldName;\n    args.fieldArgs = _fieldArgs;\n\n    return this.getImpl(args);\n  }\n\n  set<KeyT extends KeyTypeConstraints>(\n    _typeName: string | Ref<KeyT> | SetArgs<KeyT>,\n    _key?: KeyT | string | { [fieldName: string]: any },\n    _fieldName?: string | { [fieldName: string]: any } | unknown,\n    _value?: unknown\n  ): void {\n    if (typeof _typeName !== 'string') {\n      if (_key === undefined) {\n        if (isRef<KeyT>(_typeName)) {\n          throw new Error(\"Can't provide a ref as first argument and no other argument\");\n        }\n        // set({...})\n        return this.setImpl(_typeName);\n      } else {\n        assertIsRef<KeyT>(_typeName);\n        const { $ref } = _typeName;\n\n        // arguments shift\n        _value = _fieldName;\n        _fieldName = _key;\n        _key = $ref.key;\n        _typeName = $ref.typeName;\n      }\n    }\n\n    assertIsDefined(_key, 'key was not provided');\n\n    const args: SetArgs<KeyT> = {\n      typeName: _typeName,\n      key: _key as KeyT,\n    };\n\n    if (typeof _fieldName !== 'string') {\n      // set('User', 1, { name: 'Foo' })\n      if (!isRecord(_fieldName)) throw new Error('Expected value to be a record');\n\n      args.value = _fieldName;\n      return this.setImpl(args);\n    }\n\n    args.fieldName = _fieldName;\n    args.value = _value;\n\n    return this.setImpl(args);\n  }\n\n  reset() {\n    this.store = {};\n  }\n\n  private getImpl<KeyT extends KeyTypeConstraints>(args: GetArgs<KeyT>) {\n    const { typeName, key, fieldName, fieldArgs, defaultValue } = args;\n\n    if (!fieldName) {\n      if (defaultValue !== undefined && !isRecord(defaultValue)) {\n        throw new Error('`defaultValue` should be an object');\n      }\n      let valuesToInsert = defaultValue || {};\n\n      if (key) {\n        valuesToInsert = { ...valuesToInsert, ...makeRef(typeName, key) };\n      }\n\n      return this.insert(typeName, valuesToInsert, true);\n    }\n\n    assertIsDefined(key, 'key argument should be given when fieldName is given');\n\n    const fieldNameInStore: string = getFieldNameInStore(fieldName, fieldArgs);\n\n    if (\n      this.store[typeName] === undefined ||\n      this.store[typeName][key] === undefined ||\n      this.store[typeName][key][fieldNameInStore] === undefined\n    ) {\n      let value;\n      if (defaultValue !== undefined) {\n        value = defaultValue;\n      } else if (this.isKeyField(typeName, fieldName)) {\n        value = key;\n      } else {\n        value = this.generateFieldValue(typeName, fieldName, (otherFieldName, otherValue) => {\n          // if we get a key field in the mix we don't care\n          if (this.isKeyField(typeName, otherFieldName)) return;\n\n          this.set({ typeName, key, fieldName: otherFieldName, value: otherValue, noOverride: true });\n        });\n      }\n\n      this.set({ typeName, key, fieldName, fieldArgs, value, noOverride: true });\n    }\n\n    return this.store[typeName][key][fieldNameInStore];\n  }\n\n  private setImpl<KeyT extends KeyTypeConstraints>(args: SetArgs<KeyT>) {\n    const { typeName, key, fieldName, fieldArgs, noOverride } = args;\n    let { value } = args;\n    if (isMockList(value)) {\n      value = deepResolveMockList(value);\n    }\n\n    if (!fieldName) {\n      if (!isRecord(value)) {\n        throw new Error('When no `fieldName` is provided, `value` should be a record.');\n      }\n      for (const fieldName of Object.keys(value)) {\n        this.setImpl({\n          typeName,\n          key,\n          fieldName,\n          value: value[fieldName],\n          noOverride,\n        });\n      }\n      return;\n    }\n\n    const fieldNameInStore: string = getFieldNameInStore(fieldName, fieldArgs);\n\n    if (this.isKeyField(typeName, fieldName) && value !== key) {\n      throw new Error(\n        `Field ${fieldName} is a key field of ${typeName} and you are trying to set it to ${value} while the key is ${key}`\n      );\n    }\n\n    if (this.store[typeName] === undefined) {\n      this.store[typeName] = {};\n    }\n\n    if (this.store[typeName][key] === undefined) {\n      this.store[typeName][key] = {};\n    }\n\n    // if already set and we don't override\n    if (this.store[typeName][key][fieldNameInStore] !== undefined && noOverride) {\n      return;\n    }\n\n    const fieldType = this.getFieldType(typeName, fieldName);\n    const currentValue = this.store[typeName][key][fieldNameInStore];\n\n    let valueToStore;\n    try {\n      valueToStore = this.normalizeValueToStore(fieldType, value, currentValue, (typeName, values) =>\n        this.insert(typeName, values, noOverride)\n      );\n    } catch (e) {\n      throw new Error(`Value to set in ${typeName}.${fieldName} in not normalizable: ${e.message}`);\n    }\n\n    this.store[typeName][key] = {\n      ...this.store[typeName][key],\n      [fieldNameInStore]: valueToStore,\n    };\n  }\n\n  private normalizeValueToStore(\n    fieldType: GraphQLOutputType,\n    value: unknown,\n    currentValue: unknown,\n    onInsertType: (typeName: string, values: { [fieldName: string]: unknown }) => Ref\n  ): unknown {\n    const fieldTypeName = fieldType.toString();\n    if (value === null) {\n      if (!isNullableType(fieldType)) {\n        throw new Error(`should not be null because ${fieldTypeName} is not nullable. Received null.`);\n      }\n    }\n\n    const nullableFieldType = getNullableType(fieldType);\n    if (value === undefined) return this.generateValueFromType(nullableFieldType);\n\n    // deal with nesting insert\n    if (isCompositeType(nullableFieldType)) {\n      if (!isRecord(value)) throw new Error(`should be an object or null or undefined. Received ${value}`);\n\n      let joinedTypeName;\n      if (isAbstractType(nullableFieldType)) {\n        if (isRef(value)) {\n          joinedTypeName = value.$ref.typeName;\n        } else {\n          if (typeof value['__typename'] !== 'string') {\n            throw new Error(`should contain a '__typename' because ${nullableFieldType.name} an abstract type`);\n          }\n          joinedTypeName = value['__typename'];\n        }\n      } else {\n        joinedTypeName = nullableFieldType.name;\n      }\n\n      return onInsertType(joinedTypeName, isRef(currentValue) ? { ...currentValue, ...value } : value);\n    }\n\n    if (isListType(nullableFieldType)) {\n      if (!Array.isArray(value)) throw new Error(`should be an array or null or undefined. Received ${value}`);\n\n      return value.map((v, index) => {\n        return this.normalizeValueToStore(\n          nullableFieldType.ofType,\n          v,\n          currentValue && currentValue[index] ? currentValue : undefined,\n          onInsertType\n        );\n      });\n    }\n\n    return value;\n  }\n\n  private insert<KeyT extends KeyTypeConstraints>(\n    typeName: string,\n    values: { [fieldName: string]: unknown },\n    noOverride?: boolean\n  ): Ref<KeyT> {\n    const keyFieldName = this.getKeyFieldName(typeName);\n\n    let key: KeyT;\n\n    // when we generate a key for the type, we might produce\n    // other associated values with it\n    // We keep track of them and we'll insert them, with propririty\n    // for the ones that we areasked to insert\n    const otherValues: { [fieldName: string]: unknown } = {};\n\n    if (isRef<KeyT>(values)) {\n      key = values.$ref.key;\n    } else if (keyFieldName && keyFieldName in values) {\n      key = values[keyFieldName] as KeyT;\n    } else {\n      key = this.generateKeyForType<KeyT>(typeName, (otherFieldName, otherFieldValue) => {\n        otherValues[otherFieldName] = otherFieldValue;\n      });\n    }\n\n    const toInsert = { ...otherValues, ...values };\n    for (const fieldName of Object.keys(toInsert)) {\n      if (fieldName === '$ref') continue;\n      if (fieldName === '__typename') continue;\n      this.set({\n        typeName,\n        key,\n        fieldName,\n        value: toInsert[fieldName],\n        noOverride,\n      });\n    }\n\n    return makeRef(typeName, key);\n  }\n\n  private generateFieldValue(\n    typeName: string,\n    fieldName: string,\n    onOtherFieldsGenerated?: (fieldName: string, value: unknown) => void\n  ): unknown | undefined {\n    const mockedValue = this.generateFieldValueFromMocks(typeName, fieldName, onOtherFieldsGenerated);\n    if (mockedValue !== undefined) return mockedValue;\n\n    const fieldType = this.getFieldType(typeName, fieldName);\n    return this.generateValueFromType(fieldType);\n  }\n\n  private generateFieldValueFromMocks(\n    typeName: string,\n    fieldName: string,\n    onOtherFieldsGenerated?: (fieldName: string, value: unknown) => void\n  ): unknown | undefined {\n    let value;\n\n    const mock: IScalarMock | ITypeMock | undefined = this.mocks ? this.mocks[typeName] : undefined;\n    if (mock) {\n      if (typeof mock === 'function') {\n        const values = mock();\n        if (typeof values !== 'object' || values == null) {\n          throw new Error(`Value returned by the mock for ${typeName} is not an object`);\n        }\n\n        for (const otherFieldName of Object.keys(values)) {\n          if (otherFieldName === fieldName) continue;\n          if (typeof (values as any)[otherFieldName] === 'function') continue;\n          onOtherFieldsGenerated && onOtherFieldsGenerated(otherFieldName, (values as any)[otherFieldName]);\n        }\n\n        value = (values as any)[fieldName];\n        if (typeof value === 'function') value = value();\n      } else if (typeof mock[fieldName] === 'function') {\n        value = mock[fieldName]();\n      }\n    }\n\n    if (value !== undefined) return value;\n\n    const type = this.getType(typeName);\n    // GraphQL 14 Compatibility\n    const interfaces = 'getInterfaces' in type ? type.getInterfaces() : [];\n\n    if (interfaces.length > 0) {\n      for (const interface_ of interfaces) {\n        if (value) break;\n        value = this.generateFieldValueFromMocks(interface_.name, fieldName, onOtherFieldsGenerated);\n      }\n    }\n\n    return value;\n  }\n\n  private generateKeyForType<KeyT extends KeyTypeConstraints>(\n    typeName: string,\n    onOtherFieldsGenerated?: (fieldName: string, value: unknown) => void\n  ) {\n    const keyFieldName = this.getKeyFieldName(typeName);\n\n    if (!keyFieldName) return uuidv4() as KeyT;\n\n    return this.generateFieldValue(typeName, keyFieldName, onOtherFieldsGenerated) as KeyT;\n  }\n\n  private generateValueFromType(fieldType: GraphQLOutputType): unknown {\n    const nullableType = getNullableType(fieldType);\n\n    if (isScalarType(nullableType)) {\n      const mockFn = this.mocks[nullableType.name];\n      if (typeof mockFn !== 'function') throw new Error(`No mock defined for type \"${nullableType.name}\"`);\n      return mockFn();\n    } else if (isEnumType(nullableType)) {\n      const mockFn = this.mocks[nullableType.name];\n      if (typeof mockFn === 'function') return mockFn();\n\n      const values = nullableType.getValues().map(v => v.value);\n      return takeRandom(values);\n    } else if (isObjectType(nullableType)) {\n      // this will create a new random ref\n      return this.insert(nullableType.name, {});\n    } else if (isListType(nullableType)) {\n      return [...new Array(randomListLength())].map(() => this.generateValueFromType(nullableType.ofType));\n    } else if (isAbstractType(nullableType)) {\n      const mock = this.mocks[nullableType.name];\n\n      let typeName: string;\n      let values: { [key: string]: unknown } = {};\n      if (!mock) {\n        typeName = takeRandom(this.schema.getPossibleTypes(nullableType).map(t => t.name));\n      } else if (typeof mock === 'function') {\n        const mockRes = mock();\n        if (mockRes === null) return null;\n\n        if (!isRecord(mockRes)) {\n          throw new Error(`Value returned by the mock for ${nullableType.name} is not an object or null`);\n        }\n\n        values = mockRes;\n        if (typeof values['__typename'] !== 'string') {\n          throw new Error(`Please return a __typename in \"${nullableType.name}\"`);\n        }\n        typeName = values['__typename'];\n      } else if (typeof mock['__typename'] === 'function') {\n        const mockRes = mock['__typename']();\n        if (typeof mockRes !== 'string')\n          throw new Error(`'__typename' returned by the mock for abstract type ${nullableType.name} is not a string`);\n        typeName = mockRes;\n      } else {\n        throw new Error(`Please return a __typename in \"${nullableType.name}\"`);\n      }\n\n      const toInsert = {};\n      for (const fieldName of Object.keys(values)) {\n        if (fieldName === '__typename') continue;\n        const fieldValue = (values as any)[fieldName];\n        toInsert[fieldName] = typeof fieldValue === 'function' ? fieldValue() : fieldValue;\n      }\n      return this.insert(typeName, toInsert);\n    } else {\n      throw new Error(`${nullableType} not implemented`);\n    }\n  }\n\n  private getFieldType(typeName: string, fieldName: string) {\n    const type = this.getType(typeName);\n\n    const field = type.getFields()[fieldName];\n\n    if (!field) {\n      throw new Error(`${fieldName} does not exist on type ${typeName}`);\n    }\n\n    return field.type;\n  }\n\n  private getType(typeName: string) {\n    const type = this.schema.getType(typeName);\n\n    if (!type || !(isObjectType(type) || isInterfaceType(type))) {\n      throw new Error(`${typeName} does not exist on schema or is not an object or interface`);\n    }\n\n    return type;\n  }\n\n  private isKeyField(typeName: string, fieldName: string) {\n    return this.getKeyFieldName(typeName) === fieldName;\n  }\n\n  private getKeyFieldName(typeName: string): string | null {\n    const typePolicyKeyField = this.typePolicies[typeName]?.keyFieldName;\n    if (typePolicyKeyField !== undefined) {\n      if (typePolicyKeyField === false) return null;\n      return typePolicyKeyField;\n    }\n\n    const gqlType = this.getType(typeName);\n    const fieldNames = Object.keys(gqlType.getFields());\n\n    if (fieldNames.includes('id')) return 'id';\n    if (fieldNames.includes('_id')) return '+id';\n\n    return null;\n  }\n}\n\nconst getFieldNameInStore = (fieldName: string, fieldArgs?: string | { [argName: string]: any }) => {\n  if (!fieldArgs) return fieldName;\n\n  if (typeof fieldArgs === 'string') {\n    return `${fieldName}:${fieldArgs}`;\n  }\n\n  // empty args\n  if (Object.keys(fieldArgs).length === 0) {\n    return fieldName;\n  }\n\n  return `${fieldName}:${stringify(fieldArgs)}`;\n};\n"],"version":3}